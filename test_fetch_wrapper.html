<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fetch Wrapper Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    h1, h2 {
      color: #333;
    }
    .test-section {
      margin-bottom: 20px;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .success {
      background-color: #e6ffe6;
      border-color: #99cc99;
    }
    .error {
      background-color: #ffe6e6;
      border-color: #cc9999;
    }
    .pending {
      background-color: #e6e6ff;
      border-color: #9999cc;
    }
    button {
      padding: 8px 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 10px;
    }
    button:hover {
      background-color: #45a049;
    }
    pre {
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
    }
    .log {
      margin-top: 10px;
      padding: 10px;
      background-color: #f9f9f9;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <h1>Fetch Wrapper Test</h1>
  <p>This page tests the fixed fetch wrapper that prevents "body stream already read" errors.</p>
  
  <div class="test-section">
    <h2>1. Mock Response Test</h2>
    <p>Tests the fetch wrapper using mock responses:</p>
    <button id="testMock">Run Mock Tests</button>
    <div id="mockResult" class="log"></div>
  </div>

  <div class="test-section">
    <h2>2. Real API Test</h2>
    <p>Tests the fetch wrapper against a real API endpoint:</p>
    <div>
      <label for="apiUrl">API URL:</label>
      <input type="text" id="apiUrl" value="http://localhost:8000/api/v1/clients?limit=5" style="width: 300px;">
    </div>
    <button id="testApi">Test Real API</button>
    <div id="apiResult" class="log"></div>
  </div>

  <h2>Implementation Code:</h2>
  <pre id="codeSnippet">
// Our improved API fetch wrapper
async function parseJsonSafe(res) {
  try {
    return await res.clone().json();
  } catch (e) {
    console.log('Failed to parse JSON:', e.message);
    return null;
  }
}

async function parseTextSafe(res) {
  try {
    return await res.clone().text();
  } catch (e) {
    console.log('Failed to parse text:', e.message);
    return '';
  }
}

function extractMessage(body) {
  if (!body) return;
  if (typeof body === 'string') return body;
  if (typeof body.detail === 'string') return body.detail;
  if (Array.isArray(body?.detail)) {
    return body.detail.map(d => d.msg || d?.loc?.join('.')).join('; ');
  }
}

async function apiFetch(path, init = {}) {
  const API_BASE = 'http://localhost:8000/api/v1';
  const url = path.startsWith('http') ? path : `${API_BASE}${path}`;
  const res = await fetch(url, {
    credentials: 'include',
    headers: { 'Content-Type': 'application/json', ...(init?.headers || {}) },
    ...init,
  });

  const contentType = res.headers.get('content-type') || '';
  const looksJson = contentType.includes('application/json');

  if (!res.ok) {
    const json = looksJson ? await parseJsonSafe(res) : null;
    const txt = !json ? await parseTextSafe(res) : undefined;
    const message = extractMessage(json) || txt || `HTTP ${res.status}`;
    throw new Error(message);
  }

  if (looksJson) return await res.json();
  return await res.text();
}</pre>

  <script>
    // Mock Response implementation
    class MockResponse {
      constructor(status, data, contentType = 'application/json') {
        this.status = status;
        this.ok = status >= 200 && status < 300;
        this._data = typeof data === 'string' ? data : JSON.stringify(data);
        this._contentType = contentType;
        this._used = false;
      }

      clone() {
        return new MockResponse(this.status, JSON.parse(this._data), this._contentType);
      }

      get headers() {
        return {
          get: (name) => name.toLowerCase() === 'content-type' ? this._contentType : null
        };
      }

      async json() {
        if (this._used) throw new Error('Body stream already read');
        this._used = true;
        return JSON.parse(this._data);
      }

      async text() {
        if (this._used) throw new Error('Body stream already read');
        this._used = true;
        return this._data;
      }
    }

    // Fetch wrapper implementation
    async function parseJsonSafe(res) {
      try {
        return await res.clone().json();
      } catch (e) {
        console.log('Failed to parse JSON:', e.message);
        return null;
      }
    }

    async function parseTextSafe(res) {
      try {
        return await res.clone().text();
      } catch (e) {
        console.log('Failed to parse text:', e.message);
        return '';
      }
    }

    function extractMessage(body) {
      if (!body) return;
      if (typeof body === 'string') return body;
      if (typeof body.detail === 'string') return body.detail;
      if (Array.isArray(body?.detail)) {
        return body.detail.map(d => d.msg || d?.loc?.join('.')).join('; ');
      }
    }

    async function apiFetch(path, init = {}) {
      const API_BASE = 'http://localhost:8000/api/v1';
      const url = path.startsWith('http') ? path : `${API_BASE}${path}`;
      const res = await fetch(url, {
        credentials: 'include',
        headers: { 'Content-Type': 'application/json', ...(init?.headers || {}) },
        ...init,
      });

      const contentType = res.headers.get('content-type') || '';
      const looksJson = contentType.includes('application/json');

      if (!res.ok) {
        const json = looksJson ? await parseJsonSafe(res) : null;
        const txt = !json ? await parseTextSafe(res) : undefined;
        const message = extractMessage(json) || txt || `HTTP ${res.status}`;
        throw new Error(message);
      }

      if (looksJson) return await res.json();
      return await res.text();
    }

    // The broken implementation for comparison
    async function brokenFetch(path) {
      const res = await fetch(path);
      
      if (!res.ok) {
        try {
          const errorData = await res.json();
          const detail = errorData.detail || JSON.stringify(errorData);
          throw new Error(`Error: ${detail}`);
        } catch (jsonError) {
          const text = await res.text(); // This will fail with "body stream already read"
          throw new Error(`Error: ${res.status} ${text}`);
        }
      }
      
      return res.json();
    }

    // Helper to log results
    function logResult(elementId, message, isSuccess = true) {
      const container = document.getElementById(elementId);
      const className = isSuccess ? 'success' : 'error';
      container.innerHTML += `<div class="${className}">${message}</div>`;
    }

    // Test with mock responses
    document.getElementById('testMock').addEventListener('click', async () => {
      const resultDiv = document.getElementById('mockResult');
      resultDiv.innerHTML = '<div class="pending">Running tests...</div>';
      
      try {
        // Override global fetch for mock testing
        const originalFetch = window.fetch;
        window.fetch = (url) => {
          if (url.includes('success')) {
            return Promise.resolve(new MockResponse(200, { result: 'success', id: 123 }));
          } else if (url.includes('error-422')) {
            return Promise.resolve(new MockResponse(422, { 
              detail: [{ loc: ['body', 'id_number'], msg: 'invalid ID number' }] 
            }));
          } else if (url.includes('error-plain')) {
            return Promise.resolve(new MockResponse(400, 'Bad request error', 'text/plain'));
          } else {
            return Promise.resolve(new MockResponse(404, { detail: 'Resource not found' }));
          }
        };
        
        // Success case
        resultDiv.innerHTML = '<h3>Test Results:</h3>';
        try {
          const successResult = await apiFetch('/success');
          logResult('mockResult', `<strong>Success case:</strong> Got result with ID: ${successResult.id}`);
        } catch (e) {
          logResult('mockResult', `<strong>Success case failed:</strong> ${e.message}`, false);
        }
        
        // Error case with JSON response
        try {
          await apiFetch('/error-422');
          logResult('mockResult', '<strong>JSON error case:</strong> Failed, should have thrown exception', false);
        } catch (e) {
          logResult('mockResult', `<strong>JSON error case:</strong> Correctly caught error: ${e.message}`);
        }
        
        // Error case with plain text
        try {
          await apiFetch('/error-plain');
          logResult('mockResult', '<strong>Plain text error case:</strong> Failed, should have thrown exception', false);
        } catch (e) {
          logResult('mockResult', `<strong>Plain text error case:</strong> Correctly caught error: ${e.message}`);
        }
        
        // Broken implementation test
        try {
          await brokenFetch('/error-422');
          logResult('mockResult', '<strong>Broken fetch test:</strong> Failed, should show body stream error', false);
        } catch (e) {
          const isExpectedError = e.message.includes('Body stream already read');
          logResult('mockResult', 
            `<strong>Broken fetch test:</strong> ${isExpectedError ? 
              'Correctly got "Body stream already read" error' : 
              'Unexpected error: ' + e.message}`, 
            isExpectedError);
        }
        
        // Restore original fetch
        window.fetch = originalFetch;
      } catch (e) {
        resultDiv.innerHTML = `<div class="error">Test failed: ${e.message}</div>`;
      }
    });
    
    // Test with real API
    document.getElementById('testApi').addEventListener('click', async () => {
      const resultDiv = document.getElementById('apiResult');
      const apiUrl = document.getElementById('apiUrl').value;
      
      resultDiv.innerHTML = `<div class="pending">Testing API endpoint: ${apiUrl}...</div>`;
      
      try {
        const result = await apiFetch(apiUrl);
        resultDiv.innerHTML = `
          <div class="success">
            <strong>API call succeeded!</strong>
            <pre>${JSON.stringify(result, null, 2)}</pre>
          </div>
        `;
      } catch (e) {
        resultDiv.innerHTML = `
          <div class="error">
            <strong>API call failed with error:</strong>
            <pre>${e.message}</pre>
          </div>
        `;
      }
    });
  </script>
</body>
</html>
